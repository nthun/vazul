---
documentclass: jss
author:
  - name: TamÃ¡s Nagy
    orcid: 00000-0001-5244-0356
    address: |
      | Institute of Psychology,
      | ELTE Eotvos Lorend University,
      | Budapest, Hungary
    affiliation: |
      | ELTE Eotvos Lorend University
    email: \email{nagy.tamas@ppk.elte.hu} \AND
  - name: Alexandra Sarafoglou
    orcid: 0000-0003-0031-685X
    address: |
      | Department of Psychology,
      | University of Amsterdam,
      | Amsterdam, The Netherlands
    affiliation: |
      | University of Amsterdam
    email: \email{a.s.g.sarafoglou@uva.nl}
title:
  # If you use tex in the formatted title, also supply version without
  # For running headers, if needed
  formatted: "\\pkg{Vazul}: An R Package for Analysis Blinding"
  plain:     "An R Package for Analysis Blinding"
  short:     "\\pkg{Vazul}: A Capitalized Title"
abstract: >
  The abstract of the article.
keywords:
  # at least one keyword must be supplied
  formatted: [keywords, not capitalized, "\\proglang{Java}"]
  plain:     [keywords, not capitalized, Java]
preamble: >
  \usepackage{amsmath}
output: rticles::jss_article
bibliography: ../inst/bibliography.bib
csl: jss.csl   # optional, if you want JSS citation style
editor_options: 
  chunk_output_type: console
---

```{r, setup, include=FALSE}
options(prompt = 'R> ', continue = '+ ')
```

## Overview of the functionality of the vazul package
The package provides functions for blinding data to facilitate unbiased analysis. The package covers two main approaches to data blinding:

1. **Masking**: Replaces original values with anonymous labels, hiding the original information.
2. **Scrambling**: Randomizes the order of existing values while preserving all original data content.

Each approach is available at three levels:

- **Vector level**: `mask_labels()` and `scramble_values()` - operate on single vectors
- **Data frame level**: `mask_variables()` and `scramble_variables()` - operate on columns in a data frame
- **Row-wise level**: `mask_variables_rowwise()` and `scramble_variables_rowwise()` - operate within rows across columns

## Working with included Datasets

The `vazul` package includes two research datasets for demonstration and practice. The `marp` dataset comes from the Many Analysts Religion Project (MARP) dataset contains 10,535 participants from 24 countries, and includes variables about religious beliefs, well-being, and demographics. The `williams` dataset comes from a stereotyping study with 112 participants, including measures of impulsivity, opportunity, and investment in education and children.


```{r}

data(williams)
data(marp)

glimpse(williams)
glimpse(marp)

```

## Masking Functions

Masking functions replace categorical values with anonymous labels. This is useful when you want to completely hide the original information, such as treatment conditions or group assignments. Masking is best suited for categorical variables with a limited number of unique values. Therefore, the function requires character or factor vectors as input. 
The `mask_labels()` function takes a character or factor vector and replaces each unique value with a randomly assigned masked label.


```{r load_packages, message = FALSE}
library(vazul)
library(dplyr)

# Create a simple treatment vector
treatment <- c("control", "treatment", "control", "treatment", "control")

# Mask the labels
set.seed(123)
masked_treatment <- mask_labels(treatment)
masked_treatment
```

Notice that each unique value receives a unique masked label, the same original value always maps to the same masked label, and assignment of masked labels to original values is randomized. The function preserves factor structure when the input is a factor.
The prefix used for masked labels is customizable using the `prefix` argument.

```{r}
set.seed(456)
mask_labels(treatment, prefix = "group_")
```

The functionality of `mask_labels()` is extended to data frames in the `mask_variables()` function, which applies masking to multiple columns in a data frame simultaneously. Tidyselect helpers such as `starts_with()`, `any_of()`, etc. can be used to select columns. By default, each column gets its own set of masked labels with the column name as prefix. 


```{r}
experiment_1 <- data.frame(
  treatment = c("control", "intervention", "control", "intervention"),
  outcome = c("success", "failure", "success", "failure"),
  score = c(85, 92, 78, 88)
)

mask_variables(experiment_1, c("treatment", "outcome"))

```

```{r}
williams |> 
    select(subject, age, gender, ecology, Opport_1, Opport_2) |>
    mask_variables(where(is.character))
```

When `across_variables = TRUE`, all selected columns share the same mapping. This is useful when the same categories appear in multiple columns consistent masking is required across variables. 

```{r}
experiment_2 <- data.frame(
  pre_condition = c("A", "B", "C", "A"),
  post_condition = c("B", "A", "A", "C"),
  score = c(1, 2, 3, 4)
)

mask_variables(experiment_2, c("pre_condition", "post_condition"),
               across_variables = TRUE)

```

The `mask_variables_rowwise()` function applies consistent masking within each row across multiple columns. This is useful when you have multiple independent variables that require concealment. Within each row, the original values are consistently mapped to masked labels, but the mapping is independent across rows.

```{r}
experiment_3 <- data.frame(
  treat_1 = c("control", "treatment", "placebo"),
  treat_2 = c("treatment", "placebo", "control"),
  treat_3 = c("placebo", "control", "treatment"),
  id = 1:3
)

set.seed(123)
mask_variables_rowwise(experiment_3, starts_with("treat_"))

```

## Scrambling Functions

Scrambling functions randomize the order of values while preserving all original data content. This approach maintains the data distribution while breaking any connection between observations and their original values. The `scramble_values()` function randomly reorders the elements of a vector. It can be used to any type of data, including numeric, character, and factor, with any number of unique values. The function preserves the data type.

```{r}
# Numeric data
set.seed(123)
numbers <- 1:10
scramble_values(numbers)
```

Extending the scrambling functionality to data frames, `scramble_variables()` scrambles the values of specified columns. The function can also use tidyselect helpers to select columns for scrambling. 

```{r}

marp |> 
    scramble_variables(gender, education) 
    

df <- data.frame(
  x = 1:6,
  y = letters[1:6],
  group = c("A", "A", "A", "B", "B", "B")
)

set.seed(123)
scramble_variables(df, c("x", "y"))
```

By default, each column is scrambled independently. When `together = TRUE`, the selected columns are scrambled as a unit, preserving row-level relationships. This may help maintain multivariate relationships of independent variables while breaking individual links to the outcome variable.

```{r}

scramble_variables(marp, rel_1:rel_9, 
                   together = TRUE)
```

Use the `.groups` parameter to scramble within groups:

```{r}
data(williams)

# Scramble age and ecology within gender groups
set.seed(42)
williams_scrambled <- williams |>
  scramble_variables(c("age", "ecology"), .groups = "gender")

```

The `scramble_variables_rowwise()` function scrambles values within each row across specified columns. This is useful for scrambling repeated measures or item responses. Within each row, the values are shuffled among the item columns.


```{r}
df <- data.frame(
  item1 = c(1, 4, 7),
  item2 = c(2, 5, 8),
  item3 = c(3, 6, 9),
  id = 1:3
)

set.seed(123)
result <- scramble_variables_rowwise(df, c("item1", "item2", "item3"))
result
```

You can scramble multiple sets of columns independently:

```{r}
df2 <- data.frame(
  day_1 = c(1, 4, 7),
  day_2 = c(2, 5, 8),
  day_3 = c(3, 6, 9),
  score_a = c(10, 40, 70),
  score_b = c(20, 50, 80),
  id = 1:3
)

set.seed(456)
result2 <- scramble_variables_rowwise(
  df2,
  starts_with("day_"),
  c("score_a", "score_b")
)
result2
```

## Choosing between masking and scrambling

| Aspect | Masking | Scrambling |
|--------|---------|------------|
| **Original values** | Hidden (replaced) | Preserved (reordered) |
| **Distribution** | Same proportions, but new labels | Unchanged |
| **Best for** | Categorical variables | Numeric or categorical |
| **Use case** | Hide treatment conditions | Break individual links |
| **Reversibility** | Requires mapping key | Irreversible |

### When to use masking

- When you need to hide categorical labels (e.g., treatment conditions, group names)
- When analysts should not know the meaning of categories
- When you want different prefixes for different variables

### When to use scrambling

- When you want to preserve the original data distribution
- When you need to break the link between observations and values
- When working with numeric data or many unique categorical levels in a variable

## Main functions

The `vazul` package provides a comprehensive toolkit for data blinding:

| Function | Level | Purpose |
|----------|-------|---------|
| `mask_labels()` | Vector | Replace categorical values with anonymous labels |
| `mask_variables()` | Data frame | Mask multiple columns |
| `mask_variables_rowwise()` | Row-wise | Consistent masking within rows |
| `scramble_values()` | Vector | Randomize value order |
| `scramble_variables()` | Data frame | Scramble multiple columns |
| `scramble_variables_rowwise()` | Row-wise | Scramble values within rows |
| `marp` | Dataset | Many Analysts Religion Project data |
| `williams` | Dataset | Williams stereotyping study data |


